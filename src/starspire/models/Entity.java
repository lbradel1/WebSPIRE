package starspire.models;

import starspire.StarSpireApp;
import java.util.*;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.json.*;

/**
 * An entity represents a link between documents on a general level.
 * @author Patrick Fiaux, Alex Endert
 */
public class Entity implements Iterable<Document> {
    private static final Logger logger = Logger.getLogger(StarSpireApp.class.getName());
    private static int SERIAL_ID = 1;
    /**
     * This entity was user generated and qualifies as soft data.
     */
    private boolean softdata;
    private int ID;
    private String name;
    private ArrayList<Document> docs;
    private ArrayList<Search> searches;
    private double strength;    //strength of the entity, which the edge then uses
    private double initialTFIDF;    //the initial TFIDF value given
    private double TF;
    private double IDF;
    private double entityCount; //number of times entity occurs in all docs
    private ArrayList<EntDocsTF> docsTFPairs = new ArrayList<EntDocsTF>();
    

    /**
     * Default constructor empty entity
     */
    public Entity() {
        setup(++SERIAL_ID, "", new ArrayList<Document>(),new ArrayList<Search>(), false, 1);
    }

    /**
     * Create a new entity with no documents but with a specific name.
     * @param name name of entity
     */
    public Entity(String name) {
        setup(++SERIAL_ID, name, new ArrayList<Document>(),new ArrayList<Search>(), false, 1);
    }

    /**
     * Create a new entity with the option to make it 'softdata'
     * @param name name of entity
     * @param soft true if entity was generated by user actions
     */
    public Entity(String name, boolean soft) {
        setup(++SERIAL_ID, name, new ArrayList<Document>(),new ArrayList<Search>(), soft, 1);
    }

    /**
     * Load an entity from a saved JSON
     * @param ent JSON object to load
     * @param model data model this entity is part of.
     * @throws JSONException format exception
     */
    public Entity(JSONObject ent, DataModel model) throws JSONException {
        int lid;
        String n;
        double str;
        boolean soft = false;
        JSONArray JSONdocs, JSONsearches;
        ArrayList<Document> ndocs = new ArrayList<Document>();
        ArrayList<Search> nsearches = new ArrayList<Search>();
        lid = ent.getInt("ID");
        n = ent.getString("name");
        str = ent.getLong("strength");
        /*
         * Rebuild entity document links
         */
        JSONdocs = ent.getJSONArray("documents");
        for (int i = 0; i < JSONdocs.length(); i++) {
            int id;
            id = JSONdocs.getInt(i);
            Document d = model.lookUpDocument(id);
            if (d != null) {
		//add document to this entity
                ndocs.add(d);
		//add entity to this document
		d.addEntity(this);
            } else {
                logger.log(Level.WARNING, "Failed to link a document");
            }
        }

        /*
         * Rebuild entity search links
         */
        JSONsearches = ent.getJSONArray("searches");
        for (int i = 0; i < JSONsearches.length(); i++) {
            int id;
            id = JSONsearches.getInt(i);
            Search s = model.lookUpSearch(id);
            if (s != null) {
		//add document to this entity
                nsearches.add(s);
		//add entity to this document
		s.setEntity(this);
            } else {
                logger.log(Level.WARNING, "Failed to link a search");
            }
        }

        /*
         * Optional load: Softdata
         * wont crash when loading softdata if missing from file.
         */
        try {
            soft = ent.getBoolean("softdata");
        } catch (JSONException e) {
            System.err.println("Failed to load entity softdata state");
            soft = false;
        }

        setup(lid, n, ndocs, nsearches, soft, str);

        if (lid >= SERIAL_ID) {
            SERIAL_ID = lid + 1;
        }
    }

    /**
     * constructor helper.
     * @param newID id to give the entity, helpful to reuse old ids on load
     * @param newName name of the entity
     * @param newDocs list of documents, again useful on loading files
     * @param str double the strength of the entity
     */
    private void setup(int newID, String newName, ArrayList<Document> newDocs,ArrayList<Search> newSearches, boolean soft, double str) {
        docs = newDocs;
        searches = newSearches;
        ID = newID;
        name = newName;
        strength = str;
        softdata = soft;
        initialTFIDF = 0;
    }

    /**
     * This returns a JSON object representation of a node
     * @return a JSONObject representing this node's data
     * @throws JSONException something went wrong
     */
    public JSONObject getJSONObject() throws JSONException {
        JSONObject entJSON = new JSONObject();

        entJSON.put("ID", ID);
        entJSON.put("name", name);
        entJSON.put("softdata", softdata);
        entJSON.put("strength", strength);
        /**
         * Add Document ID list
         */
        JSONArray darr = new JSONArray();
        entJSON.put("documents", darr);
        for (Document doc : docs) {
            darr.put(doc.getId());
        }

        /**
         * Add Search ID list
         */
        JSONArray sarr = new JSONArray();
        entJSON.put("searches", sarr);
        for (Search s : searches) {
            sarr.put(s.getId());
        }

        return entJSON;
    }
    
    
    
    /**
     * Get the initial TFIDF value for this entity
     * @return double the initial TFIDF value for this entity
     */
    public double getTFIDF() {
        return initialTFIDF;
    }

    /**
     * Set the initial TFDF value for this entity
     * @param value double the initial TFIDF value for this entity
     */
    public void setTFIDF(double value) {
        initialTFIDF = value;
    }
    
    public void setTF(double tf) {
        TF = tf;
    }
    
    public double getTF() {
        return TF;
    }
    
    public void setIDF(double idf) {
        IDF = idf;
    }
    
    public double getIDF() {
        return IDF;
    }
    
    public void setEntityCount(double count) {
        entityCount = count;
    }
    
    public double getEntityCount() {
        return entityCount;
    }
    
    public void addTFdoc(double tf, Document d) {
        docsTFPairs.add(new EntDocsTF(tf, d));
    }
    
    public double getTFIDFdoc(Document d) {
        for(int i = 0; i < docsTFPairs.size(); i++) {
            if(docsTFPairs.get(i).getDoc().getName().compareTo(d.getName()) == 0) {
                //System.out.println("TF: " + docsTFPairs.get(i).getTF());
                //System.out.println("IDF: " + IDF);
                return docsTFPairs.get(i).getTF() * IDF;
            }
        }
        return 0;
    }
    
    /**
     * Get the strength of this entity
     * strength = 0 to no limit
     * @return strength
     */
    public double getStrength() {
        return strength;
    }

    /**
     * Sets the strength of the entity.
     * @param d strength of the entity
     */
    protected void setStrength(double d) {
        strength = d;
    }


    /**
     * Updates the name of this entity
     * WARNING use with care! changing the name of the object
     * wont change the model much! Probably shouldn't be used.
     * @param n New entity name
     */
    protected void setName(String n) {
        if(n.length() < 0) {
            name = n;
        }
    }

    /**
     * Add a single document to this entity's list.
     * @param d Document to add
     */
    public void addDocument(Document d) {
        docs.add(d);
    }

    /**
     * Add a single search to this entity's list.
     * @param s Search to add
     */
    protected void addSearch(Search s) {
        searches.add(s);
    }

    /**
     * Returns the search at the specified index position.
     * @precondition i < this.searches && i > 0
     * @param i index of the search in the entity's array
     * @return search
     */
    public Search getSearch(int i) {
	return searches.get(i);
    }

    /**
     * Returns the document at the specified index position.
     * @precondition i < this.documents && i > 0
     * @param i index of the document in the entity's array
     * @return document
     */
    public Document getDocument(int i) {
	return docs.get(i);
    }

    /**
     * Returns the name of the entity
     * @return String for the entity name
     */
    public String getName() {
        return name;
    }

    /**
     * Finds if the Document exists in the current Document list.
     * @param doc The document to check if it exists.
     * @return boolean True if it exists, False if not
     */
    public boolean hasDocument(Document doc) {
        for (Document d : docs) {
            if (doc.getName().equals(d.getName())) {
                return true;
            }
        }
        return false;
    }

    public boolean hasSearch(Search s) {
        for (Search ss : searches) {
            if (ss.getSearchTerm().equals(s.getSearchTerm())) {
                return true;
            }
        }
        return false;
    }


    /**
     * Remove a single document from this entity's list.
     * @param d Document to remove
     */
    protected void removeDocument(Document d) {
        docs.remove(d);
    }

    protected void removeSearch(Search s) {
        searches.remove(s);
    }

    /**
     * Returns the number of documents this entity links to
     * @return count of documents
     */
    public int documents() {
        return docs.size();
    }

    /**
     * Returns an iterator of search for this entity
     * @return Search iterator
     */
    public Iterator<Search> searchIterator() {
        return searches.iterator();
    }

    /**
     * Returns the number of searches for this entity
     * @return count of searches
     */
    public int searches() {
        return searches.size();
    }

    /**
     * Returns an iterator for the documents of this entity.
     * @return Document iterator.
     */
    public Iterator<Document> iterator() {
        return docs.iterator();
    }

    /**
     * Return whether the entity was user created or not.
     * @return true of soft data or false otherwise
     * (automatically generated by software or imported)
     */
    public boolean isSoftData() {
        return softdata;
    }

    /**
     * Return the id of this entity;
     * @return id number
     */
    public int getID() {
        return ID;
    }

    /**
     * Returns a string version of the entity.
     * @return String representation of the entity including serial id and name.
     */
    @Override
    public String toString() {
        return "Entity-" + ID + ": " + name + " (strength: " + String.format("%.2f", strength) + ", docs: "+ docs.size() +", searches: "+ searches.size() + ")";
    }

    /**
     * Overrides Equal for entity.
     * If not null and an entity:
     * Compares the id and name, if they match we're good.
     * @param o Object to compare to this entity
     * @return true if they're the same entity.
     */
    @Override
    public boolean equals(Object o) {
	if (o != null) {
	    if (o.getClass() == this.getClass()) {
		Entity e = (Entity) o;
		if (e.ID != this.ID) {
		    return false;
		}
		if (!e.name.equals(this.name)) {
		    return false;
		}
		return true;
	    }
	}
	return false;
    }
}
